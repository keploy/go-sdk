package kmongo

import (
	"context"
	"encoding/gob"
	"errors"
	"fmt"
	"go.keploy.io/server/pkg/models"

	"github.com/keploy/go-sdk/keploy"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"
	"go.uber.org/zap"
)

// NewCollection creates and returns an instance of Collection that contains actual
// pointer to mongo's collection. This is done in order to mock mongo CRUD operations, so that:
//  - In "capture" mode, stores the encoded output(generated by mocked methods of mongo.Collection) into keploy's Context Deps array.
//  - In "test" mode, decodes its stored encoded output which are present in the keploy's Context Deps array without calling mocked methods of mongo.Collection.
//  - In "off" mode, returns the output generated after calling mocked method of mongo.Collection.
//
// cl parameter is pointer to mongo's collection instance created by (*mongo.Database).Collection
// method. It should not be nil, else warning will logged and nil is returned.
//
// Returns pointer to integrations.Collection which contains mongo.Collection. Nil is returned when mongo.Collection is nil.
func NewCollection(cl *mongo.Collection) *Collection {
	if cl == nil {
		return nil
	}
	gob.Register(primitive.ObjectID{})
	logger, _ := zap.NewProduction()
	defer func() {
		_ = logger.Sync() // flushes buffer, if any
	}()
	return &Collection{Collection: *cl, log: logger}
}

// Collection In order to mock mongo operations, mongo collection is embedded into Collection.
type Collection struct {
	mongo.Collection
	log *zap.Logger
}

// SingleResult countains instance of mongo.SingleResult to mock its methods so that:
//  - In "capture" mode, stores the encoded output(generated by mocked methods of mongo.SingleResult) into keploy's Context Deps array.
//  - In "test" mode, decodes its stored encoded output which are present in the keploy's Context Deps array without calling mocked methods of mongo.SingleResult.
//  - In "off" mode, returns the output generated after calling mocked method of mongo.SingleResult.
type SingleResult struct {
	mongo.SingleResult
	filter interface{}
	opts   []options.FindOneOptions
	ctx    context.Context
	log    *zap.Logger
}

// Err mocks mongo's SingleResult Err() which will called in "capture" or "off" mode as stated above in SingleResult.
//
// See https://pkg.go.dev/go.mongodb.org/mongo-driver/mongo#SingleResult.Err for more information about SingleResult.Err.
func (msr *SingleResult) Err() error {
	if keploy.GetModeFromContext(msr.ctx) == keploy.MODE_OFF {
		err := msr.SingleResult.Err()
		return err
	}
	var err error
	var kerr *keploy.KError = &keploy.KError{}
	kctx, er := keploy.GetState(msr.ctx)
	if er != nil {
		return er
	}
	mode := kctx.Mode
	switch mode {
	case "test":
		//don't run mongo query as it is stored in context
	case "capture":
		err = msr.SingleResult.Err()
	default:
		return errors.New("integrations: Not in a valid sdk mode")
	}

	meta := map[string]string{
		"name":           "mongodb",
		"type":           string(models.NoSqlDB),
		"operation":      "FindOne.Err",
		"filter":         fmt.Sprint(msr.filter),
		"FindOneOptions": fmt.Sprint(msr.opts),
	}

	if err != nil {
		kerr = &keploy.KError{Err: err}
	}
	mock, res := keploy.ProcessDep(msr.ctx, msr.log, meta, kerr)

	if mock {
		var mockErr error
		x := res[0].(*keploy.KError)
		if x.Err != nil {
			mockErr = x.Err
		}
		return mockErr
	}
	return err
}

// Decode mocks mongo's SingleResult.Decode which will called in "capture" or "off" mode as stated above in SingleResult.
//
// See https://pkg.go.dev/go.mongodb.org/mongo-driver/mongo#SingleResult.Decode for more information about SingleResult.Decode.
func (msr *SingleResult) Decode(v interface{}) error {
	if keploy.GetModeFromContext(msr.ctx) == keploy.MODE_OFF {
		err := msr.SingleResult.Decode(v)
		return err
	}
	var err error
	var kerr = &keploy.KError{}
	kctx, er := keploy.GetState(msr.ctx)
	if er != nil {
		return er
	}
	mode := kctx.Mode
	switch mode {
	case "test":
		//dont run mongo query as it is stored in context
	case "capture":
		err = msr.SingleResult.Decode(v)
	default:
		return errors.New("integrations: Not in a valid sdk mode")
	}

	meta := map[string]string{
		"name":           "mongodb",
		"type":           string(models.NoSqlDB),
		"operation":      "FindOne.Decode",
		"filter":         fmt.Sprint(msr.filter),
		"FindOneOptions": fmt.Sprint(msr.opts),
	}

	if err != nil {
		kerr = &keploy.KError{Err: err}
	}
	mock, res := keploy.ProcessDep(msr.ctx, msr.log, meta, v, kerr)

	if mock {
		var mockErr error
		// rv := reflect.ValueOf(v)
		// rv.Elem().Set(reflect.ValueOf(res[0]).Elem())

		x := res[1].(*keploy.KError)
		if x.Err != nil {
			mockErr = x.Err
		}
		return mockErr
	}
	return err
}

// FindOne method creates and returns pointer of SingleResult which containes mongo.SingleResult
// in order to mock its method. It mocks Collection.FindOne method explained above in integrations.NewCollections.
//
// See https://pkg.go.dev/go.mongodb.org/mongo-driver/mongo#Collection.FindOne for information about Collection.FindOne.
func (c *Collection) FindOne(ctx context.Context, filter interface{}, opts ...*options.FindOneOptions) *SingleResult {
	if keploy.GetModeFromContext(ctx) == keploy.MODE_OFF {
		sr := c.Collection.FindOne(ctx, filter, opts...)
		return &SingleResult{
			SingleResult: *sr,
			filter:       filter,
			log:          c.log,
			ctx:          ctx,
		}
	}
	derivedOpts := []options.FindOneOptions{}
	for _, j := range opts {
		derivedOpts = append(derivedOpts, *j)
	}
	kctx, er := keploy.GetState(ctx)
	if er != nil {
		return &SingleResult{
			filter: filter,
			opts:   derivedOpts,
			log:    c.log,
			ctx:    ctx,
		}
	}
	mode := kctx.Mode
	var sr *mongo.SingleResult
	switch mode {
	case "test":
		return &SingleResult{
			filter: filter,
			opts:   derivedOpts,
			log:    c.log,
			ctx:    ctx,
		}
	case "capture":
		sr = c.Collection.FindOne(ctx, filter, opts...)
	default:
		return &SingleResult{
			filter: filter,
			opts:   derivedOpts,
			log:    c.log,
			ctx:    ctx,
		}
	}

	return &SingleResult{
		SingleResult: *sr,
		filter:       filter,
		opts:         derivedOpts,
		log:          c.log,
		ctx:          ctx,
	}
}

// InsertOne method mocks Collection.InsertOne of mongo.Collection. Actual method isn't called in test mode only as stated in integrations.NewCollection.
//
// See https://pkg.go.dev/go.mongodb.org/mongo-driver/mongo#Collection.InsertOne for information about Collection.InsertOne.
func (c *Collection) InsertOne(ctx context.Context, document interface{},
	opts ...*options.InsertOneOptions) (*mongo.InsertOneResult, error) {
	if keploy.GetModeFromContext(ctx) == keploy.MODE_OFF {
		output, err := c.Collection.InsertOne(ctx, document, opts...)
		return output, err
	}
	var output = &mongo.InsertOneResult{}
	var err error
	var kerr = &keploy.KError{}
	var data []interface{}
	data = append(data, document)
	for _, j := range opts {
		data = append(data, j)
	}
	o, e := c.getOutput(ctx, "InsertOne", data)
	if o != nil {
		output = o.(*mongo.InsertOneResult)
	}
	err = e

	derivedOpts := []options.InsertOneOptions{}
	for _, j := range opts {
		derivedOpts = append(derivedOpts, *j)
	}
	meta := map[string]string{
		"name":             "mongodb",
		"type":             string(models.NoSqlDB),
		"operation":        "InsertOne",
		"document":         fmt.Sprint(document),
		"InsertOneOptions": fmt.Sprint(derivedOpts),
	}

	if err != nil {
		kerr = &keploy.KError{Err: err}
		output = &mongo.InsertOneResult{}
	}
	mock, res := keploy.ProcessDep(ctx, c.log, meta, output, kerr)

	if mock {
		var mockOutput *mongo.InsertOneResult
		var mockErr error
		if res[0] != nil {
			mockOutput = res[0].(*mongo.InsertOneResult)
		}
		x := res[1].(*keploy.KError)
		if x.Err != nil {
			mockErr = x.Err
		}
		return mockOutput, mockErr
	}
	return output, err
}

// Cursor contains emedded mongo.Cursor in order to override its methods.
type Cursor struct {
	mongo.Cursor
	filter interface{}
	pipeline interface{}
	findOpts   []options.FindOptions
	aggregateOpts []options.AggregateOptions
	ctx    context.Context
	log    *zap.Logger
}

// Err mocks mongo's Cursor.Err in order to store and replay its output according SDK mode.
//
// See https://pkg.go.dev/go.mongodb.org/mongo-driver/mongo#Cursor.Err for information about Cursor.Err.
func (cr *Cursor) Err() error {
	if keploy.GetModeFromContext(cr.ctx) == keploy.MODE_OFF {
		err := cr.Cursor.Err()
		return err
	}
	var err error
	var kerr = &keploy.KError{}
	kctx, er := keploy.GetState(cr.ctx)
	if er != nil {
		return er
	}
	mode := kctx.Mode
	switch mode {
	case "test":
		//dont run mongo query as it is stored in context
		err = nil
	case "capture":
		err = cr.Cursor.Err()
	default:
		return errors.New("integrations: Not in a valid sdk mode")
	}

	meta := map[string]string{
		"name":        "mongodb",
		"type":        string(models.NoSqlDB),
	}
	if cr.filter!=nil{
		meta["filter"] = fmt.Sprint(cr.filter)
		meta["FindOptions"] = fmt.Sprint(cr.findOpts)
		meta["operation"] = "Find.Err"
	} else {
		meta["pipeline"] = fmt.Sprint(cr.pipeline)
		meta["AggregateOptions"] = fmt.Sprint(cr.aggregateOpts)
		meta["operation"] = "Aggregate.Err"

	}

	if err != nil {
		kerr = &keploy.KError{Err: err}
	}
	mock, res := keploy.ProcessDep(cr.ctx, cr.log, meta, kerr)

	if mock {
		var mockErr error
		x := res[0].(*keploy.KError)
		if x.Err != nil {
			mockErr = x.Err
		}
		return mockErr
	}
	return err
}

// Close mocks mongo's Cursor.Close in order to store and replay its output according SDK mode.
//
// See https://pkg.go.dev/go.mongodb.org/mongo-driver/mongo#Cursor.Close for information about Cursor.Close.
func (cr *Cursor) Close(ctx context.Context) error {
	if keploy.GetModeFromContext(ctx) == keploy.MODE_OFF {
		err := cr.Cursor.Close(ctx)
		return err
	}
	var err error
	var kerr = &keploy.KError{}
	kctx, er := keploy.GetState(cr.ctx)
	if er != nil {
		return er
	}
	mode := kctx.Mode
	switch mode {
	case "test":
		//dont run mongo query as it is stored in context
		err = nil
	case "capture":
		err = cr.Cursor.Close(ctx)
	default:
		return errors.New("integrations: Not in a valid sdk mode")
	}

	meta := map[string]string{
		"name":        "mongodb",
		"type":        string(models.NoSqlDB),
	}
	if cr.filter!=nil{
		meta["filter"] = fmt.Sprint(cr.filter)
		meta["FindOptions"] = fmt.Sprint(cr.findOpts)
		meta["operation"] = "Find.Err"
	} else {
		meta["pipeline"] = fmt.Sprint(cr.pipeline)
		meta["AggregateOptions"] = fmt.Sprint(cr.aggregateOpts)
		meta["operation"] = "Aggregate.Err"

	}

	if err != nil {
		kerr = &keploy.KError{Err: err}
	}
	mock, res := keploy.ProcessDep(cr.ctx, cr.log, meta, kerr)

	if mock {
		var mockErr error
		x := res[0].(*keploy.KError)
		if x.Err != nil {
			mockErr = x.Err
		}
		return mockErr
	}
	return err
}

// TryNext mocks mongo's Cursor.TryNext in order to store and replay its output according SDK mode.
//
// See https://pkg.go.dev/go.mongodb.org/mongo-driver/mongo#Cursor.TryNext for information about Cursor.TryNext.
func (cr *Cursor) TryNext(ctx context.Context) bool {
	if keploy.GetModeFromContext(ctx) == keploy.MODE_OFF {
		return cr.Cursor.TryNext(ctx)
	}
	kctx, er := keploy.GetState(cr.ctx)
	if er != nil {
		return false
	}
	var output *bool
	mode := kctx.Mode
	switch mode {
	case "test":
		//dont run mongo query as it is stored in context
		n := false
		output = &n
	case "capture":
		n := cr.Cursor.TryNext(ctx)
		output = &n
	default:
		return false
	}

	meta := map[string]string{
		"name":        "mongodb",
		"type":        string(models.NoSqlDB),
	}
	if cr.filter!=nil{
		meta["filter"] = fmt.Sprint(cr.filter)
		meta["FindOptions"] = fmt.Sprint(cr.findOpts)
		meta["operation"] = "Find.Err"
	} else {
		meta["pipeline"] = fmt.Sprint(cr.pipeline)
		meta["AggregateOptions"] = fmt.Sprint(cr.aggregateOpts)
		meta["operation"] = "Aggregate.Err"

	}

	mock, res := keploy.ProcessDep(cr.ctx, cr.log, meta, output)

	if mock {
		if res[0] != nil {
			output = res[0].(*bool)
		}
	}
	return *output
}

// All mocks mongo's Cursor.All in order to store and replay its output according SDK mode.
//
// See https://pkg.go.dev/go.mongodb.org/mongo-driver/mongo#Cursor.All for information about Cursor.All.
func (cr *Cursor) All(ctx context.Context, results interface{}) error {
	if keploy.GetModeFromContext(ctx) == keploy.MODE_OFF {
		err := cr.Cursor.All(ctx, results)
		return err
	}
	var err error
	var kerr = &keploy.KError{}
	kctx, er := keploy.GetState(cr.ctx)
	if er != nil {
		return er
	}
	mode := kctx.Mode
	switch mode {
	case "test":
		//dont run mongo query as it is stored in context
		err = nil
	case "capture":
		err = cr.Cursor.All(ctx, results)
	default:
		return errors.New("integrations: Not in a valid sdk mode")
	}

	meta := map[string]string{
		"name":        "mongodb",
		"type":        string(models.NoSqlDB),
	}
	if cr.filter!=nil{
		meta["filter"] = fmt.Sprint(cr.filter)
		meta["FindOptions"] = fmt.Sprint(cr.findOpts)
		meta["operation"] = "Find.Err"
	} else {
		meta["pipeline"] = fmt.Sprint(cr.pipeline)
		meta["AggregateOptions"] = fmt.Sprint(cr.aggregateOpts)
		meta["operation"] = "Aggregate.Err"

	}

	if err != nil {
		kerr = &keploy.KError{Err: err}
	}
	mock, res := keploy.ProcessDep(cr.ctx, cr.log, meta, results, kerr)

	if mock {
		var mockErr error
		x := res[1].(*keploy.KError)
		if x.Err != nil {
			mockErr = x.Err
		}
		return mockErr
	}
	return err
}

// Next mocks mongo's Cursor.Next in order to store and replay its output according SDK mode.
//
// See https://pkg.go.dev/go.mongodb.org/mongo-driver/mongo#Cursor.Next for information about Cursor.Next.
func (cr *Cursor) Next(ctx context.Context) bool {
	if keploy.GetModeFromContext(ctx) == keploy.MODE_OFF {
		return cr.Cursor.Next(ctx)
	}
	kctx, er := keploy.GetState(cr.ctx)
	if er != nil {
		return false
	}
	var output *bool
	mode := kctx.Mode
	switch mode {
	case "test":
		//dont run mongo query as it is stored in context
		n := false
		output = &n
	case "capture":
		n := cr.Cursor.Next(ctx)
		output = &n
	default:
		return false
	}

	meta := map[string]string{
		"name":        "mongodb",
		"type":        string(models.NoSqlDB),
	}
	if cr.filter!=nil{
		meta["filter"] = fmt.Sprint(cr.filter)
		meta["FindOptions"] = fmt.Sprint(cr.findOpts)
		meta["operation"] = "Find.Err"
	} else {
		meta["pipeline"] = fmt.Sprint(cr.pipeline)
		meta["AggregateOptions"] = fmt.Sprint(cr.aggregateOpts)
		meta["operation"] = "Aggregate.Err"

	}

	mock, res := keploy.ProcessDep(cr.ctx, cr.log, meta, output)

	if mock {
		if res[0] != nil {
			output = res[0].(*bool)
		}
	}
	return *output
}

// Decode mocks mongo's Cursor.Decode in order to store and replay its output according SDK mode.
//
// See https://pkg.go.dev/go.mongodb.org/mongo-driver/mongo#Cursor.Decode for information about Cursor.Decode.
func (cr *Cursor) Decode(v interface{}) error {
	if keploy.GetModeFromContext(cr.ctx) == keploy.MODE_OFF {
		err := cr.Cursor.Decode(v)
		return err
	}
	var err error
	var kerr = &keploy.KError{}
	kctx, er := keploy.GetState(cr.ctx)
	if er != nil {
		return er
	}
	mode := kctx.Mode
	switch mode {
	case "test":
		//dont run mongo query as it is stored in context
		err = nil
	case "capture":
		err = cr.Cursor.Decode(v)
	default:
		return errors.New("integrations: Not in a valid sdk mode")
	}

	meta := map[string]string{
		"name":        "mongodb",
		"type":        string(models.NoSqlDB),
	}
	if cr.filter!=nil{
		meta["filter"] = fmt.Sprint(cr.filter)
		meta["FindOptions"] = fmt.Sprint(cr.findOpts)
		meta["operation"] = "Find.Err"
	} else {
		meta["pipeline"] = fmt.Sprint(cr.pipeline)
		meta["AggregateOptions"] = fmt.Sprint(cr.aggregateOpts)
		meta["operation"] = "Aggregate.Err"

	}

	if err != nil {
		kerr = &keploy.KError{Err: err}
	}
	mock, res := keploy.ProcessDep(cr.ctx, cr.log, meta, v, kerr)

	if mock {
		var mockErr error
		x := res[1].(*keploy.KError)
		if x.Err != nil {
			mockErr = x.Err
		}
		return mockErr
	}
	return err
}

// Find creates and returns the instance of pointer to Cursor which have overridden methods of mongo.Cursor.
// Actual Collection.Find is called only in "capture" or "off" mode.
//
// For information about Collection.Find, See https://pkg.go.dev/go.mongodb.org/mongo-driver/mongo#Collection.Find.
func (c *Collection) Find(ctx context.Context, filter interface{},
	opts ...*options.FindOptions) (*Cursor, error) {
	if keploy.GetModeFromContext(ctx) == keploy.MODE_OFF {
		cursor, err := c.Collection.Find(ctx, filter, opts...)
		return &Cursor{
			Cursor: *cursor,
			filter: filter,
			ctx:    ctx,
			log:    c.log,
		}, err
	}

	derivedOpts := []options.FindOptions{}
	for _, j := range opts {
		derivedOpts = append(derivedOpts, *j)
	}
	kctx, er := keploy.GetState(ctx)
	if er != nil {
		return &Cursor{
			filter: filter,
			findOpts:   derivedOpts,
			log:    c.log,
			ctx:    ctx,
		}, er
	}
	mode := kctx.Mode
	var (
		cursor *mongo.Cursor
		err    error
	)
	switch mode {
	case "test":
		//don't call method in test mode
		return &Cursor{
			filter: filter,
			findOpts:   derivedOpts,
			log:    c.log,
			ctx:    ctx,
		}, err
	case "capture":
		cursor, err = c.Collection.Find(ctx, filter, opts...)
		return &Cursor{
			Cursor: *cursor,
			filter: filter,
			findOpts:   derivedOpts,
			log:    c.log,
			ctx:    ctx,
		}, err
	default:
		c.log.Error("integrations: Not in a valid sdk mode")
		return &Cursor{
			filter: filter,
			findOpts:   derivedOpts,
			log:    c.log,
			ctx:    ctx,
		}, errors.New("integrations: Not in a valid sdk mode")
	}

}

// InsertMany method mocks Collection.InsertMany of mongo.
//
// For information about Collection.InsertMany, visit https://pkg.go.dev/go.mongodb.org/mongo-driver@v1.8.0/mongo#Collection.InsertMany.
func (c *Collection) InsertMany(ctx context.Context, documents []interface{},
	opts ...*options.InsertManyOptions) (*mongo.InsertManyResult, error) {
	if keploy.GetModeFromContext(ctx) == keploy.MODE_OFF {
		output, err := c.Collection.InsertMany(ctx, documents, opts...)
		return output, err
	}
	var output = &mongo.InsertManyResult{}
	var err error
	var kerr *keploy.KError = &keploy.KError{}
	var data []interface{}
	data = append(data, documents)
	for _, j := range opts {
		data = append(data, j)
	}
	o, e := c.getOutput(ctx, "InsertMany", data)
	if o != nil {
		output = o.(*mongo.InsertManyResult)
	}
	err = e

	derivedOpts := []options.InsertManyOptions{}
	for _, j := range opts {
		derivedOpts = append(derivedOpts, *j)
	}
	meta := map[string]string{
		"name":              "mongodb",
		"type":              string(models.NoSqlDB),
		"operation":         "InsertMany",
		"documents":         fmt.Sprint(documents),
		"InsertManyOptions": fmt.Sprint(derivedOpts),
	}

	if err != nil {
		kerr = &keploy.KError{Err: err}
		output = &mongo.InsertManyResult{}
	}
	mock, res := keploy.ProcessDep(ctx, c.log, meta, output, kerr)

	if mock {
		var mockOutput *mongo.InsertManyResult
		var mockErr error
		if res[0] != nil {
			mockOutput = res[0].(*mongo.InsertManyResult)
		}
		x := res[1].(*keploy.KError)
		if x.Err != nil {
			mockErr = x.Err
		}
		return mockOutput, mockErr
	}
	return output, err
}

// UpdateOne method mocks Collection.UpdateOne of mongo.
//
// For information about Collection.UpdateOne, refer to https://pkg.go.dev/go.mongodb.org/mongo-driver@v1.8.0/mongo#Collection.UpdateOne.
func (c *Collection) UpdateOne(ctx context.Context, filter interface{}, update interface{},
	opts ...*options.UpdateOptions) (*mongo.UpdateResult, error) {
	if keploy.GetModeFromContext(ctx) == keploy.MODE_OFF {
		output, err := c.Collection.UpdateOne(ctx, filter, update, opts...)
		return output, err
	}
	var output = &mongo.UpdateResult{}
	var err error
	var kerr = &keploy.KError{}
	var data []interface{}
	data = append(data, filter)
	data = append(data, update)
	for _, j := range opts {
		data = append(data, j)
	}
	o, e := c.getOutput(ctx, "UpdateOne", data)
	if o != nil {
		output = o.(*mongo.UpdateResult)
	}
	err = e

	derivedOpts := []options.UpdateOptions{}
	for _, j := range opts {
		derivedOpts = append(derivedOpts, *j)
	}
	meta := map[string]string{
		"name":          "mongodb",
		"type":          string(models.NoSqlDB),
		"operation":     "UpdateOne",
		"filter":        fmt.Sprint(filter),
		"update":        fmt.Sprint(update),
		"UpdateOptions": fmt.Sprint(derivedOpts),
	}

	if err != nil {
		kerr = &keploy.KError{Err: err}
		output = &mongo.UpdateResult{}
	}
	mock, res := keploy.ProcessDep(ctx, c.log, meta, output, kerr)

	if mock {
		var mockOutput *mongo.UpdateResult
		var mockErr error
		if res[0] != nil {
			mockOutput = res[0].(*mongo.UpdateResult)
		}
		x := res[1].(*keploy.KError)
		if x.Err != nil {
			mockErr = x.Err
		}
		return mockOutput, mockErr
	}
	return output, err
}

// UpdateMany method mocks Collection.UpdateMany of mongo.
//
// For information about Collection.UpdateMany, go to https://pkg.go.dev/go.mongodb.org/mongo-driver@v1.8.0/mongo#Collection.UpdateMany.
func (c *Collection) UpdateMany(ctx context.Context, filter interface{}, update interface{},
	opts ...*options.UpdateOptions) (*mongo.UpdateResult, error) {
	if keploy.GetModeFromContext(ctx) == keploy.MODE_OFF {
		output, err := c.Collection.UpdateMany(ctx, filter, update, opts...)
		return output, err
	}
	var output = &mongo.UpdateResult{}
	var err error
	var kerr *keploy.KError = &keploy.KError{}
	var data []interface{}
	data = append(data, filter)
	data = append(data, update)
	for _, j := range opts {
		data = append(data, j)
	}
	o, e := c.getOutput(ctx, "UpdateMany", data)
	if o != nil {
		output = o.(*mongo.UpdateResult)
	}
	err = e

	derivedOpts := []options.UpdateOptions{}
	for _, j := range opts {
		derivedOpts = append(derivedOpts, *j)
	}
	meta := map[string]string{
		"name":          "mongodb",
		"type":          string(models.NoSqlDB),
		"operation":     "UpdateMany",
		"filter":        fmt.Sprint(filter),
		"update":        fmt.Sprint(update),
		"UpdateOptions": fmt.Sprint(derivedOpts),
	}

	if err != nil {
		kerr = &keploy.KError{Err: err}
		output = &mongo.UpdateResult{}
	}
	mock, res := keploy.ProcessDep(ctx, c.log, meta, output, kerr)

	if mock {
		var mockOutput *mongo.UpdateResult
		var mockErr error
		if res[0] != nil {
			mockOutput = res[0].(*mongo.UpdateResult)
		}
		x := res[1].(*keploy.KError)
		if x.Err != nil {
			mockErr = x.Err
		}
		return mockOutput, mockErr
	}
	return output, err
}

// DeleteOne method mocks Collection.DeleteOne of mongo.
//
// See https://pkg.go.dev/go.mongodb.org/mongo-driver@v1.8.0/mongo#Collection.DeleteOne for
// information about Collection.DeleteOne.
func (c *Collection) DeleteOne(ctx context.Context, filter interface{},
	opts ...*options.DeleteOptions) (*mongo.DeleteResult, error) {
	if keploy.GetModeFromContext(ctx) == keploy.MODE_OFF {
		output, err := c.Collection.DeleteOne(ctx, filter, opts...)
		return output, err
	}
	var output = &mongo.DeleteResult{}
	var err error
	var kerr = &keploy.KError{}
	var data []interface{}
	data = append(data, filter)
	for _, j := range opts {
		data = append(data, j)
	}
	o, e := c.getOutput(ctx, "DeleteOne", data)
	if o != nil {
		output = o.(*mongo.DeleteResult)
	}
	err = e

	derivedOpts := []options.DeleteOptions{}
	for _, j := range opts {
		derivedOpts = append(derivedOpts, *j)
	}
	meta := map[string]string{
		"name":          "mongodb",
		"type":          string(models.NoSqlDB),
		"operation":     "DeleteOne",
		"filter":        fmt.Sprint(filter),
		"DeleteOptions": fmt.Sprint(derivedOpts),
	}

	if err != nil {
		kerr = &keploy.KError{Err: err}
		output = &mongo.DeleteResult{}
	}
	mock, res := keploy.ProcessDep(ctx, c.log, meta, output, kerr)

	if mock {
		var mockOutput *mongo.DeleteResult
		var mockErr error
		if res[0] != nil {
			mockOutput = res[0].(*mongo.DeleteResult)
		}
		x := res[1].(*keploy.KError)
		if x.Err != nil {
			mockErr = x.Err
		}
		return mockOutput, mockErr
	}
	return output, err
}

// DeleteMany method mocks Collection.DeleteMany of mongo inorder to call it only in "capture" or "off" mode.
//
// See https://pkg.go.dev/go.mongodb.org/mongo-driver@v1.8.0/mongo#Collection.DeleteMany for information about Collection.DeleteMany.
func (c *Collection) DeleteMany(ctx context.Context, filter interface{},
	opts ...*options.DeleteOptions) (*mongo.DeleteResult, error) {
	if keploy.GetModeFromContext(ctx) == keploy.MODE_OFF {
		output, err := c.Collection.DeleteMany(ctx, filter, opts...)
		return output, err
	}
	var output *mongo.DeleteResult = &mongo.DeleteResult{}
	var err error
	var kerr = &keploy.KError{}
	var data []interface{}
	data = append(data, filter)
	for _, j := range opts {
		data = append(data, j)
	}
	o, e := c.getOutput(ctx, "DeleteMany", data)
	if o != nil {
		output = o.(*mongo.DeleteResult)
	}
	err = e

	derivedOpts := []options.DeleteOptions{}
	for _, j := range opts {
		derivedOpts = append(derivedOpts, *j)
	}
	meta := map[string]string{
		"name":          "mongodb",
		"type":          string(models.NoSqlDB),
		"operation":     "DeleteMany",
		"filter":        fmt.Sprint(filter),
		"DeleteOptions": fmt.Sprint(derivedOpts),
	}

	if err != nil {
		kerr = &keploy.KError{Err: err}
		output = &mongo.DeleteResult{}
	}
	mock, res := keploy.ProcessDep(ctx, c.log, meta, output, kerr)

	if mock {
		var mockOutput *mongo.DeleteResult
		var mockErr error
		if res[0] != nil {
			mockOutput = res[0].(*mongo.DeleteResult)
		}
		x := res[1].(*keploy.KError)
		if x.Err != nil {
			mockErr = x.Err
		}
		return mockOutput, mockErr
	}
	return output, err
}

// Distinct method mocks Collection.Distinct of mongo inorder to call it only in "capture" or "off" mode.
//
// See https://pkg.go.dev/go.mongodb.org/mongo-driver/mongo#Collection.Distinct for more info about Distinct.
func (c *Collection) Distinct(ctx context.Context, fieldName string, filter interface{}, opts ...*options.DistinctOptions) ([]interface{}, error){
	if keploy.GetModeFromContext(ctx) == keploy.MODE_OFF {
		output, err := c.Collection.Distinct(ctx, fieldName, filter, opts...)
		return output, err
	}
	var (
		output *[]interface{} = &[]interface{}{}
		err error
		kerr = &keploy.KError{}
		data []interface{}
	)
	data = append(data, fieldName)
	data = append(data, filter)
	for _, j := range opts {
		data = append(data, j)
	}
	o, e := c.getOutput(ctx, "Distinct", data)
	if o != nil {
		dis := o.([]interface{})
		output = &dis
	}
	err = e
	derivedOpts := []options.DistinctOptions{}
	for _, j := range opts {
		derivedOpts = append(derivedOpts, *j)
	}
	meta := map[string]string{
		"name":            "mongodb",
		"type":            string(models.NoSqlDB),
		"operation":       "Distinct",
		"fieldName":       fieldName,
		"filter":          fmt.Sprint(filter),
		"DistinctOptions": fmt.Sprint(derivedOpts),
	}
	kerr.Err = err
	mock, res := keploy.ProcessDep(ctx, c.log, meta, output, kerr)
	if mock {
		var mockErr error
		x := res[1].(*keploy.KError)
		if x.Err != nil {
			mockErr = x.Err
		}
		return *output, mockErr
	}
	return *output, err
}

// CountDocuments method mocks Collection.CountDocuments of mongo inorder to call it only in "capture" or "off" mode.
//
// See https://pkg.go.dev/go.mongodb.org/mongo-driver/mongo#Collection.CountDocuments for more info about CountDocuments.
func (c *Collection) CountDocuments(ctx context.Context, filter interface{}, opts ...*options.CountOptions) (int64, error){
	if keploy.GetModeFromContext(ctx) == keploy.MODE_OFF {
		output, err := c.Collection.CountDocuments(ctx, filter, opts...)
		return output, err
	}
	var (
		output *int64
		err error
		kerr *keploy.KError = &keploy.KError{}
		data []interface{}
	)
	data = append(data, filter)
	for _, j := range opts {
		data = append(data, j)
	}
	o, e := c.getOutput(ctx, "CountDocuments", data)
	if o != nil {
		count := o.(int64)
		output = &count
	}
	err = e
	derivedOpts := []options.CountOptions{}
	for _, j := range opts {
		derivedOpts = append(derivedOpts, *j)
	}
	meta := map[string]string{
		"name":            "mongodb",
		"type":            string(models.NoSqlDB),
		"operation":       "CountDocuments",
		"filter":          fmt.Sprint(filter),
		"CountOptions":    fmt.Sprint(derivedOpts),
	}
	kerr.Err = err
	if output==nil{
		var count int64 = 0
		output = &count
	}
	mock, res := keploy.ProcessDep(ctx, c.log, meta, output, kerr)
	if mock {
		var mockErr error
		x := res[1].(*keploy.KError)
		if x.Err != nil {
			mockErr = x.Err
		}
		return *output, mockErr
	}
	return *output, err
}

// Aggregate method mocks Collection.Aggregate of mongo inorder to call it only in "capture" or "off" mode.
//
// See https://pkg.go.dev/go.mongodb.org/mongo-driver/mongo#Collection.Aggregate for more info about Aggregate.
func (c *Collection) Aggregate(ctx context.Context, pipeline interface{}, opts ...*options.AggregateOptions) (*Cursor, error) {
	if keploy.GetModeFromContext(ctx) == keploy.MODE_OFF {
		cursor, err := c.Collection.Aggregate(ctx, pipeline, opts...)
		return &Cursor{
			Cursor: *cursor,
			pipeline: pipeline,
			ctx:    ctx,
			log:    c.log,
		}, err
	}

	derivedOpts := []options.AggregateOptions{}
	for _, j := range opts {
		derivedOpts = append(derivedOpts, *j)
	}
	kctx, er := keploy.GetState(ctx)
	if er != nil {
		return &Cursor{
			pipeline: pipeline,
			aggregateOpts:   derivedOpts,
			log:    c.log,
			ctx:    ctx,
		}, er
	}
	mode := kctx.Mode
	var (
		cursor *mongo.Cursor
		err    error
	)
	switch mode {
	case "test":
		//don't call method in test mode
		return &Cursor{
			pipeline: pipeline,
			aggregateOpts:   derivedOpts,
			log:    c.log,
			ctx:    ctx,
		}, err
	case "capture":
		cursor, err = c.Collection.Aggregate(ctx, pipeline, opts...)
		return &Cursor{
			Cursor: *cursor,
			pipeline: pipeline,
			aggregateOpts:   derivedOpts,
			log:    c.log,
			ctx:    ctx,
		}, err
	default:
		c.log.Error("integrations: Not in a valid sdk mode")
		return &Cursor{
			pipeline: pipeline,
			aggregateOpts:   derivedOpts,
			log:    c.log,
			ctx:    ctx,
		}, errors.New("integrations: Not in a valid sdk mode")
	}

}

func (c *Collection) getOutput(ctx context.Context, str string, data []interface{}) (interface{}, error) {
	var (
		output interface{}
		err    error
	)
	kctx, er := keploy.GetState(ctx)
	if er != nil {
		return nil, er
	}
	mode := kctx.Mode
	switch mode {
	case "test":
		//dont run mongo query as it is stored in context
		err = nil
	case "capture":
		output, err = c.callMethod(ctx, str, data)

	default:
		return nil, errors.New("integrations: Not in a valid sdk mode")
	}
	return output, err
}

func (c *Collection) callMethod(ctx context.Context, str string, data []interface{}) (interface{}, error) {
	var (
		output interface{}
		err    error
	)
	switch str {
	case "InsertOne":
		doc := data[0]
		data = data[1:]
		var opts []*options.InsertOneOptions
		for _, d := range data {
			opts = append(opts, d.(*options.InsertOneOptions))
		}
		output, err = c.Collection.InsertOne(ctx, doc, opts...)
	case "InsertMany":
		doc := data[0].([]interface{})
		data = data[1:]
		var opts []*options.InsertManyOptions
		for _, d := range data {
			opts = append(opts, d.(*options.InsertManyOptions))
		}
		output, err = c.Collection.InsertMany(ctx, doc, opts...)
	case "UpdateOne":
		filter := data[0]
		update := data[1]
		data = data[2:]
		var opts []*options.UpdateOptions
		for _, d := range data {
			opts = append(opts, d.(*options.UpdateOptions))
		}
		output, err = c.Collection.UpdateOne(ctx, filter, update, opts...)
	case "UpdateMany":
		filter := data[0]
		update := data[1]
		data = data[2:]
		var opts []*options.UpdateOptions
		for _, d := range data {
			opts = append(opts, d.(*options.UpdateOptions))
		}
		output, err = c.Collection.UpdateMany(ctx, filter, update, opts...)
	case "DeleteOne":
		filter := data[0]
		data = data[1:]
		var opts []*options.DeleteOptions
		for _, d := range data {
			opts = append(opts, d.(*options.DeleteOptions))
		}
		output, err = c.Collection.DeleteOne(ctx, filter, opts...)
	case "DeleteMany":
		filter := data[0]
		data = data[1:]
		var opts []*options.DeleteOptions
		for _, d := range data {
			opts = append(opts, d.(*options.DeleteOptions))
		}
		output, err = c.Collection.DeleteMany(ctx, filter, opts...)
	case "Distinct":
		fieldName := data[0]
		filter := data[1]
		data = data[2:]
		var opts []*options.DistinctOptions
		for _, d := range data {
			opts = append(opts, d.(*options.DistinctOptions))
		}
		output, err = c.Collection.Distinct(ctx, fieldName.(string), filter, opts...)
	case "CountDocuments": 
		filter := data[0]
		data = data[1:]
		var opts []*options.CountOptions
		for _, d := range data {
			opts = append(opts, d.(*options.CountOptions))
		}
		output, err = c.Collection.CountDocuments(ctx, filter, opts...)
	default:
		return nil, errors.New("integerations: SDK Not supported for this method")
	}
	return output, err
}
